<!DOCTYPE html>
<html lang="en">

  <head>
    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-GX80NH2PQ2"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-GX80NH2PQ2');
    </script>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <link rel="stylesheet" href="./dist/main.css" />
    <link href="https://fonts.googleapis.com/css2?family=Comfortaa:wght@700&display=swap" rel="stylesheet">    
    <link href="https://fonts.cdnfonts.com/css/cascadia-code" rel="stylesheet">
    <link rel="icon" href="https://cdn.iconscout.com/icon/premium/png-128-thumb/binary-tree-diagram-484863.png">
    <script src="./dist/main.js"></script>
    <title>Binary Tree Visualizer</title>
  </head>

<header>

  <h1>Binary Search Tree Visualizer</h1>


    <button class="button-50" role="button" id="lessons" name="false">Lessons</button>
    <button class="button-50" role="button" id="code" name="false">Code</button>

  <div class="profile">
    <a target="_blank" href="https://github.com/MudassarMemon/JavascriptDemo"><img id="dev-links" src="https://img.icons8.com/sf-ultralight/52/000000/github.png"></a>
    <a target="_blank" href="https://www.linkedin.com/in/mudassar-memon-0a48b1125"><img id="dev-links" src="https://img.icons8.com/ios-filled/50/000000/linkedin.png"></a>
  </div>
</header>

<body>

  <div id="slide-container">
    <div class="slides">
      
      <ul>
      <li><button id="prev"><img id="prev" src="https://img.icons8.com/plasticine/100/000000/arrow.png"></button></li>
      <li class="close"><button id="close"><img id="close" src="./src/img/close.png"></i></button></li>
      <li><button id="next"><img id="next" src="https://img.icons8.com/plasticine/100/000000/arrow.png"></button></li>
      </ul>

      <div class="slide" id="0">
        <h2>1. Introduction to Binary Search Trees:</h2>
        <p>A Binary Search Tree is a hierarchical data structure that stores elements in a way that enables efficient searching, insertion, and deletion operations.</p>
        <p>Each node in a BST has a value and at most two children: a left child and a right child.</p>
        <p>The Binary Search Tree property dictates that the values in the left subtree of a node are less than or equal to the value of the node, while the values in the right subtree are greater.</p>
        <img id="slide1" src="https://miro.medium.com/v2/resize:fit:4800/format:webp/1*Dqr5x78EjriHUFRWp5NEHQ.png" alt="">
      </div>
      
      <div class="slide" id="1">
        <h2>2. Characteristics and Terminology:</h2>
        <p><strong>Node:</strong> Each element in the BST is represented by a node containing a value and pointers to left and right children.</p>
        <p><strong>Root:</strong> The topmost node in the tree.</p>
        <p><strong>Parent and Children:</strong> Nodes have a parent node above them and children nodes below them.</p>
        <p><strong>Left Child and Right Child:</strong> Children are categorized based on their relation to their parent's value.</p>
        <p><strong>Subtree:</strong> A node and its descendants form a subtree.</p>
        <img id="slide2" src="https://miro.medium.com/v2/resize:fit:1100/format:webp/1*16ssjanNpVUASrg1Cs4oJA.png" alt="">
      </div>
    
      <div class="slide" id="2">
        <h2>3. Operations on Binary Search Trees:</h2>
        <p><strong>Insertion:</strong> To insert a new element, compare its value with nodes as you traverse the tree. Move left for smaller values and right for larger values until you find an empty spot to insert the new node.</p>
        <p><strong>Search:</strong> Compare the target value with nodes while traversing the tree. This guides you to the correct subtree, narrowing the search space until you find the element or determine its absence.</p>
        <p><strong>Deletion:</strong> Deleting a node requires reorganizing the tree while maintaining the BST property. Different cases arise based on the node's children.</p>
        <img alt="" id="slide3" src="https://cdn.icon-icons.com/icons2/865/PNG/512/Citycons_magnify_icon-icons.com_67940.png">
      </div>
      
      <div class="slide" id="3">
        <h2>4. Traversing a Binary Search Tree:</h2>
        <p><strong>In-order Traversal:</strong> Traverse the left subtree, visit the current node, then traverse the right subtree. Produces values in ascending order.</p>
        <p><strong>Pre-order Traversal:</strong> Visit the current node, traverse the left subtree, then traverse the right subtree. Used for making a copy of the tree.</p>
        <p><strong>Post-order Traversal:</strong> Traverse the left subtree, traverse the right subtree, then visit the current node. Used for deleting nodes from the tree.</p>
        <img alt="" id="slide4" src="https://t3.ftcdn.net/jpg/05/98/77/38/360_F_598773884_IdKyaPgeePB5CgynjS6PizKxCWbyOnrv.jpg">
      </div>
      
      <div class="slide" id="4">
        <h2>5. Advantages and Complexity Analysis:</h2>
        <p>BSTs offer efficient average-case performance for search, insertion, and deletion when balanced.</p>
        <p>Average time complexity for these operations is O(log n), where n is the number of nodes in the tree.</p>
        <p>However, in the worst case, if the tree becomes skewed, operations can take O(n) time.</p>
        <img alt="" id="slide5" src="https://miro.medium.com/v2/resize:fit:1400/1*Dumf5ar9SxfkF89w6useUA.png">
      </div>
      
      <div class="slide" id="5">
        <h2>6. Maintaining Balance:</h2>
        <p>To ensure efficient operations in all cases, various balanced BSTs like AVL trees and Red-Black trees are used.</p>
        <p>These trees maintain balance through rotations and color-based techniques, keeping the height logarithmic and preserving the O(log n) time complexity.</p>
        <img alt="" id="slide6" src="https://miro.medium.com/v2/resize:fit:1284/1*YCWEjg515gqAjFojHioZ8Q.png">
      </div>
      
      <div class="slide" id="6">
        <h2>7. Applications:</h2>
        <p>Binary Search Trees are used in databases, as their search efficiency aclass="slide" ids in quick retrieval of data.</p>
        <p>They're also useful for implementing sorting algorithms like Binary Tree Sort.</p>
        <p>In compilers, symbol tables are often implemented using BSTs.</p>
        <img alt="" id="slide7" src="https://miro.medium.com/v2/resize:fit:3840/1*mLqtKV1FjUg-WKlLW-cXjQ.jpeg">
      </div>
      
      <div class="slide" id="7">
        <h2>8. Conclusion:</h2>
        <p>Binary Search Trees are a powerful tool for efficient data storage, search, and manipulation.</p>
        <p>Understanding their structure and properties is crucial for designing effective algorithms and data structures in computer science.</p>
        <img alt="" id="slide8" src="https://static.vecteezy.com/system/resources/previews/028/687/842/original/good-job-medal-award-free-vector.jpg">
      </div>
    </div>
  </div>





  <div id="code-container">
    <div class="code">
      
      <ul>
      <li><img id="javascriptCode" name= "active" src="https://www.vhv.rs/dpng/d/456-4562295_library-of-javascript-icon-graphic-freeuse-png-files.png"></li>
      <li><img id="pythonCode" name= "inactive"src="https://logos-world.net/wp-content/uploads/2021/10/Python-Symbol.png"></li>
      <li><img id="rubyCode" name= "inactive" src="https://cdn.icon-icons.com/icons2/2415/PNG/512/ruby_plain_wordmark_logo_icon_146362.png"></li>
      <li class="closecode"><button id="closecode"><img id="closecode" src="./src/img/close.png"></i></button></li>
    </ul>

    <pre class="codeslide" id="java">

        Javascript Implementation:

        1 | class Node {
        2 |     constructor(value) {
        3 |         this.value = value;
        4 |         this.left = null;
        5 |         this.right = null;
        6 |     }
        7 | }
        8 |
        9 | class BinaryTree {
       10 |     constructor() {
       11 |         this.root = null;
       12 |     }
       13 |
       14 |     insert(value) {
       15 |         const newNode = new Node(value);
       16 |         if (!this.root) {
       17 |             this.root = newNode;
       18 |             return;
       19 |         }
       20 |
       21 |         this._insertRecursive(this.root, newNode);
       22 |     }
       23 |
       24 |     _insertRecursive(currentNode, newNode) {
       25 |         if (newNode.value < currentNode.value) {
       26 |             if (!currentNode.left) {
       27 |                 currentNode.left = newNode;
       28 |             } else {
       29 |                 this._insertRecursive(currentNode.left, newNode);
       30 |             }
       31 |         } else {
       32 |             if (!currentNode.right) {
       33 |                 currentNode.right = newNode;
       34 |             } else {
       35 |                 this._insertRecursive(currentNode.right, newNode);
       36 |             }
       37 |         }
       38 |     }
       39 |
       40 |     search(value) {
       41 |         return this._searchRecursive(this.root, value);
       42 |     }
       43 |
       44 |     _searchRecursive(currentNode, value) {
       45 |         if (!currentNode) {
       46 |             return false;
       47 |         }
       48 |
       49 |         if (currentNode.value === value) {
       50 |             return true;
       51 |         } else if (value < currentNode.value) {
       52 |             return this._searchRecursive(currentNode.left, value);
       53 |         } else {
       54 |             return this._searchRecursive(currentNode.right, value);
       55 |         }
       56 |     }
       57 |
       58 |     remove(value) {
       59 |         this.root = this._removeRecursive(this.root, value);
       60 |     }
       61 |
       62 |     _removeRecursive(currentNode, value) {
       63 |         if (!currentNode) {
       64 |             return null;
       65 |         }
       66 |
       67 |         if (value === currentNode.value) {
       68 |             if (!currentNode.left) {
       69 |                 return currentNode.right;
       70 |             } else if (!currentNode.right) {
       71 |                 return currentNode.left;
       72 |             } else {
       73 |                 const minValue = this._findMinValue(currentNode.right);
       74 |                 currentNode.value = minValue;
       75 |                 currentNode.right = this._removeRecursive(currentNode.right, minValue);
       76 |             }
       77 |         } else if (value < currentNode.value) {
       78 |             currentNode.left = this._removeRecursive(currentNode.left, value);
       79 |         } else {
       80 |             currentNode.right = this._removeRecursive(currentNode.right, value);
       81 |         }
       82 |
       83 |         return currentNode;
       84 |     }
       85 |
       86 |     _findMinValue(node) {
       87 |         while (node.left) {
       88 |             node = node.left;
       89 |         }
       90 |         return node.value;
       91 |     }
       92 | }       
      </pre>

      <pre class="codeslide" id="python">

        Python Implementation:

        1 | class Node:
        2 |     def __init__(self, value):
        3 |         self.value = value
        4 |         self.left = None
        5 |         self.right = None
        6 | 
        7 | class BinaryTree:
        8 |     def __init__(self):
        9 |         self.root = None
       10 | 
       11 |     def insert(self, value):
       12 |         new_node = Node(value)
       13 |         if not self.root:
       14 |             self.root = new_node
       15 |             return
       16 |         
       17 |         self._insert_recursive(self.root, new_node)
       18 |     
       19 |     def _insert_recursive(self, current_node, new_node):
       20 |         if new_node.value < current_node.value:
       21 |             if not current_node.left:
       22 |                 current_node.left = new_node
       23 |             else:
       24 |                 self._insert_recursive(current_node.left, new_node)
       25 |         else:
       26 |             if not current_node.right:
       27 |                 current_node.right = new_node
       28 |             else:
       29 |                 self._insert_recursive(current_node.right, new_node)
       30 | 
       31 |     def search(self, value):
       32 |         return self._search_recursive(self.root, value)
       33 | 
       34 |     def _search_recursive(self, current_node, value):
       35 |         if not current_node:
       36 |             return False
       37 |         
       38 |         if current_node.value == value:
       39 |             return True
       40 |         elif value < current_node.value:
       41 |             return self._search_recursive(current_node.left, value)
       42 |         else:
       43 |             return self._search_recursive(current_node.right, value)
       44 |     
       45 |     def remove(self, value):
       46 |         self.root = self._remove_recursive(self.root, value)
       47 | 
       48 |     def _remove_recursive(self, current_node, value):
       49 |         if not current_node:
       50 |             return None
       51 |         
       52 |         if value == current_node.value:
       53 |             if not current_node.left:
       54 |                 return current_node.right
       55 |             elif not current_node.right:
       56 |                 return current_node.left
       57 |             else:
       58 |                 min_value = self._find_min_value(current_node.right)
       59 |                 current_node.value = min_value
       60 |                 current_node.right = self._remove_recursive(current_node.right, min_value)
       61 |         elif value < current_node.value:
       62 |             current_node.left = self._remove_recursive(current_node.left, value)
       63 |         else:
       64 |             current_node.right = self._remove_recursive(current_node.right, value)
       65 |         
       66 |         return current_node
       67 |     
       68 |     def _find_min_value(self, node):
       69 |         while node.left:
       70 |             node = node.left
       71 |         return node.value
       
        
      </pre>

      <pre class="codeslide" id="ruby">

        Ruby Implementation: 
        
        1 | class Node
        2 |     attr_accessor :value, :left, :right
        3 |     
        4 |     def initialize(value)
        5 |         @value = value
        6 |         @left = nil
        7 |         @right = nil
        8 |     end
        9 | end
       10 | 
       11 | class BinaryTree
       12 |     attr_accessor :root
       13 |     
       14 |     def initialize
       15 |         @root = nil
       16 |     end
       17 |     
       18 |     def insert(value)
       19 |         new_node = Node.new(value)
       20 |         if @root.nil?
       21 |             @root = new_node
       22 |             return
       23 |         end
       24 |         
       25 |         insert_recursive(@root, new_node)
       26 |     end
       27 |     
       28 |     def insert_recursive(current_node, new_node)
       29 |         if new_node.value < current_node.value
       30 |             if current_node.left.nil?
       31 |                 current_node.left = new_node
       32 |             else
       33 |                 insert_recursive(current_node.left, new_node)
       34 |             end
       35 |         else
       36 |             if current_node.right.nil?
       37 |                 current_node.right = new_node
       38 |             else
       39 |                 insert_recursive(current_node.right, new_node)
       40 |             end
       41 |         end
       42 |     end
       43 |     
       44 |     def search(value)
       45 |         search_recursive(@root, value)
       46 |     end
       47 |     
       48 |     def search_recursive(current_node, value)
       49 |         return false if current_node.nil?
       50 |         
       51 |         if current_node.value == value
       52 |             return true
       53 |         elsif value < current_node.value
       54 |             search_recursive(current_node.left, value)
       55 |         else
       56 |             search_recursive(current_node.right, value)
       57 |         end
       58 |     end
       59 |     
       60 |     def remove(value)
       61 |         @root = remove_recursive(@root, value)
       62 |     end
       63 |     
       64 |     def remove_recursive(current_node, value)
       65 |         return nil if current_node.nil?
       66 |         
       67 |         if value == current_node.value
       68 |             if current_node.left.nil?
       69 |                 return current_node.right
       70 |             elsif current_node.right.nil?
       71 |                 return current_node.left
       72 |             else
       73 |                 min_value = find_min_value(current_node.right)
       74 |                 current_node.value = min_value
       75 |                 current_node.right = remove_recursive(current_node.right, min_value)
       76 |             end
       77 |         elsif value < current_node.value
       78 |             current_node.left = remove_recursive(current_node.left, value)
       79 |         else    
       80 |             current_node.right = remove_recursive(current_node.right, value)
       81 |         end
       82 |         
       83 |         current_node
       84 |     end
       85 |     
       86 |     def find_min_value(node)
       87 |         while node.left
       88 |             node = node.left
       89 |         end
       90 |         node.value
       91 |     end
       92 | end
       
      </pre>
    
    </div>
  </div>


  <div id="canvas-container">
    
  <img class="question" src="https://static-00.iconduck.com/assets.00/question-mark-circled-icon-512x512-wsm5hkwj.png"></a>
    <div id="tutorial"> 
        <div><h2>Welcome to the Binary Search Tree Visualizer!</h2>
        <h3>Get a better idea of how binary search trees operate through this visual demonstration. Interact with the binary search tree (BST) using the buttons below and see the BST at work!</h3> 
        </div>

        <div>
        <p>"Generate Random" -> generates a new binary search tree</p>
        <p>"Insert Node" -> inserts a node with the given value</p>
        <p>"Remove Node" -> removes a node with the given value</p>
        <p>"Search" -> searches for a node with the given value</p>
        </div>

        <div>
        <p>Learn more about binary search trees by clicking "Lessons" at the top of the page!</p>
        <p>View the code implementation by clicking "Code" at the top of the page!</p>
        </div>
    </div>

  <canvas id="canvas"></canvas>
    
    <div id="canvas-buttons">

      <div>
      <button class="canvas-button" id="generate-random">
        <span class="button_top"> Generate Random
        </span>
      </button>
    </div>

      <div>
      <input type="text" id="insert" class="canvas-input" value="">
      <button class="canvas-button" id="insert">
        <span class="button_top"> Insert Node
        </span>
      </button>    
      </div>

      <div>
      <input type="text" id="remove" class="canvas-input" value="">
      <button class="canvas-button" width="1500" height="700" id="remove">
        <span class="button_top"> Remove Node
        </span>
      </button>    
    </div>

    <div>
      <input type="text" id="search" class="canvas-input" value="">
      <button class="canvas-button" id="search">
        <span class="button_top"> Search
        </span>
      </button>    
    </div>

    </div>

  </div>
</body>

</html>

